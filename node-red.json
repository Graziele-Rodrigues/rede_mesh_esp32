[
    {
        "id": "tab1",
        "type": "tab",
        "label": "Painel Mesh",
        "disabled": false,
        "info": ""
    },
    {
        "id": "d7cacd98f609ab2b",
        "type": "ui_base",
        "theme": {
            "name": "theme-custom",
            "lightTheme": {
                "default": "#0094CE",
                "baseColor": "#322f30",
                "baseFont": "Arial Black,Arial Black,Gadget,sans-serif",
                "edited": true,
                "reset": false
            },
            "darkTheme": {
                "default": "#097479",
                "baseColor": "#9ea3a3",
                "baseFont": "Lucida Sans Typewriter,Lucida Console,Monaco,monospace",
                "edited": true,
                "reset": false
            },
            "customTheme": {
                "name": "TCC",
                "default": "#4B7930",
                "baseColor": "#4B7930",
                "baseFont": "Times New Roman,Times,serif",
                "reset": false
            },
            "themeState": {
                "base-color": {
                    "default": "#4B7930",
                    "value": "#4B7930",
                    "edited": true
                },
                "page-titlebar-backgroundColor": {
                    "value": "#4B7930",
                    "edited": false
                },
                "page-backgroundColor": {
                    "value": "#111111",
                    "edited": false
                },
                "page-sidebar-backgroundColor": {
                    "value": "#333333",
                    "edited": false
                },
                "group-textColor": {
                    "value": "#6db046",
                    "edited": false
                },
                "group-borderColor": {
                    "value": "#555555",
                    "edited": false
                },
                "group-backgroundColor": {
                    "value": "#333333",
                    "edited": false
                },
                "widget-textColor": {
                    "value": "#eeeeee",
                    "edited": false
                },
                "widget-backgroundColor": {
                    "value": "#4b7930",
                    "edited": false
                },
                "widget-borderColor": {
                    "value": "#333333",
                    "edited": false
                },
                "base-font": {
                    "value": "Times New Roman,Times,serif"
                }
            },
            "angularTheme": {
                "primary": "indigo",
                "accents": "blue",
                "warn": "red",
                "background": "grey",
                "palette": "light"
            }
        },
        "site": {
            "name": "Node-RED Dashboard",
            "hideToolbar": "false",
            "allowSwipe": "false",
            "lockMenu": "false",
            "allowTempTheme": "true",
            "dateFormat": "DD/MM/YYYY",
            "sizes": {
                "sx": 100,
                "sy": 50,
                "gx": 6,
                "gy": 6,
                "cx": 6,
                "cy": 6,
                "px": 0,
                "py": 0
            }
        }
    },
    {
        "id": "6ec4dcef.913b24",
        "type": "mqtt-broker",
        "name": "mosquitto publico",
        "broker": "mqtt://test.mosquitto.org",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "15",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "b931a41ca7c16188",
        "type": "sqlitedb",
        "db": "C:/Users/grazi/TCC/rede_mesh.db",
        "mode": "RWC"
    },
    {
        "id": "mqtt_broker",
        "type": "mqtt-broker",
        "name": "Broker MQTT",
        "broker": "localhost",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "compatmode": false,
        "protocolVersion": 4,
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthPayload": "",
        "closeTopic": "",
        "closePayload": "",
        "willTopic": "",
        "willQos": "0",
        "willPayload": ""
    },
    {
        "id": "aba_mesh",
        "type": "ui_tab",
        "name": "Painel Mesh",
        "icon": "dashboard",
        "order": 1,
        "disabled": false,
        "hidden": false
    },
    {
        "id": "grupo_sensores",
        "type": "ui_group",
        "name": "Dados Sensores",
        "tab": "aba_mesh",
        "order": 1,
        "disp": true,
        "width": 15,
        "collapse": false
    },
    {
        "id": "grupo_rssi",
        "type": "ui_group",
        "name": "RSSI",
        "tab": "aba_mesh",
        "order": 2,
        "disp": true,
        "width": 15,
        "collapse": false
    },
    {
        "id": "grupo_metrics",
        "type": "ui_group",
        "name": "Métricas",
        "tab": "aba_mesh",
        "order": 3,
        "disp": true,
        "width": 15,
        "collapse": false
    },
    {
        "id": "c43853a14aa4af82",
        "type": "ui_group",
        "name": "Ações na Rede",
        "tab": "aba_mesh",
        "order": 4,
        "disp": true,
        "width": 15,
        "collapse": false,
        "className": ""
    },
    {
        "id": "mqtt_rssi",
        "type": "mqtt in",
        "z": "tab1",
        "name": "RSSI MQTT",
        "topic": "/topic/mesh/rssi",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 390,
        "y": 560,
        "wires": [
            [
                "cd2ca644d1528406"
            ]
        ]
    },
    {
        "id": "table_rssi",
        "type": "ui_table",
        "z": "tab1",
        "group": "grupo_rssi",
        "name": "Tabela RSSI",
        "order": 1,
        "width": 15,
        "height": 4,
        "columns": [
            {
                "field": "mac",
                "title": "MAC",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "rssi",
                "title": "RSSI",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            }
        ],
        "outputs": 0,
        "cts": false,
        "x": 850,
        "y": 560,
        "wires": []
    },
    {
        "id": "mqtt_metrics",
        "type": "mqtt in",
        "z": "tab1",
        "name": "Métricas MQTT",
        "topic": "/topic/mesh/metricas",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": false,
        "inputs": 0,
        "x": 420,
        "y": 680,
        "wires": [
            [
                "96866108bbb66ddd"
            ]
        ]
    },
    {
        "id": "table_metrics",
        "type": "ui_table",
        "z": "tab1",
        "group": "grupo_metrics",
        "name": "Tabela Métricas",
        "order": 1,
        "width": 0,
        "height": 0,
        "columns": [
            {
                "field": "Sucesso",
                "title": "Sucesso",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "Perda",
                "title": "Perda",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "RTT",
                "title": "RTT",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "Camadas",
                "title": "Camadas",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "Nós na Rede",
                "title": "Nós na Rede",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "Trocas Pai",
                "title": "Trocas Pai",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "Ult. Troca",
                "title": "Ult. Troca",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "Retransmissões",
                "title": "Retransmissões",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            }
        ],
        "outputs": 0,
        "cts": false,
        "x": 880,
        "y": 680,
        "wires": []
    },
    {
        "id": "cd2ca644d1528406",
        "type": "function",
        "z": "tab1",
        "name": "rssi",
        "func": "// Recupera a tabela atual da memória do fluxo\nlet tabela = flow.get(\"rssi_table\") || [];\n\nlet novo = {\n    mac: msg.payload.mac,\n    rssi: msg.payload.rssi\n};\n\nlet index = tabela.findIndex(item => item.mac === novo.mac);\n\nif (index !== -1) {\n    // Atualiza se já existe\n    tabela[index].rssi = novo.rssi;\n} else {\n    // Adiciona se for novo MAC\n    tabela.push(novo);\n}\n\n// Salva de volta na memória\nflow.set(\"rssi_table\", tabela);\n\n// Envia a tabela completa para o ui_table\nmsg.payload = tabela;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 560,
        "wires": [
            [
                "table_rssi"
            ]
        ]
    },
    {
        "id": "cd8425e2db43371a",
        "type": "mqtt in",
        "z": "tab1",
        "name": "Sensor MQTT",
        "topic": "/topic/mesh/sensor",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 390,
        "y": 440,
        "wires": [
            [
                "9bd16a5d882acace",
                "8c547d7b3fc3dd64"
            ]
        ]
    },
    {
        "id": "9bd16a5d882acace",
        "type": "function",
        "z": "tab1",
        "name": "sensores",
        "func": "// Recupera a tabela atual da memória do fluxo\nlet sensorTable = flow.get(\"sensor_table\") || [];\n\n// Obtém o timestamp enviado pelo sensor (em ms)\nconst latency = parseInt(msg.payload.latency_ms, 10);\n\n// Cria o objeto com dados atualizados\nlet novo = {\n  mac: msg.payload.mac,\n  temperatura: parseFloat(msg.payload.temp).toFixed(2),\n  umidade: parseFloat(msg.payload.hum).toFixed(2),\n  latencia: latency\n};\n\n// Verifica se o MAC já existe na tabela\nlet index = sensorTable.findIndex(item => item.mac === novo.mac);\n\nif (index !== -1) {\n  // Atualiza os valores existentes\n  sensorTable[index] = { ...sensorTable[index], ...novo };\n} else {\n  // Adiciona nova entrada\n  sensorTable.push(novo);\n}\n\n// Armazena a tabela atualizada no flow\nflow.set(\"sensor_table\", sensorTable);\n\n// Envia a tabela para o próximo nó (ex: ui_table)\nmsg.payload = sensorTable;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 620,
        "y": 440,
        "wires": [
            [
                "56789c177d54f1b7"
            ]
        ]
    },
    {
        "id": "56789c177d54f1b7",
        "type": "ui_table",
        "z": "tab1",
        "group": "grupo_sensores",
        "name": "Tabela sensores",
        "order": 4,
        "width": 15,
        "height": 3,
        "columns": [
            {
                "field": "mac",
                "title": "MAC",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "temperatura",
                "title": "Temperatura",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "umidade",
                "title": "Umidade",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            },
            {
                "field": "latencia",
                "title": "Latência (ms)",
                "width": "",
                "align": "left",
                "formatter": "plaintext",
                "formatterParams": {
                    "target": "_blank"
                }
            }
        ],
        "outputs": 0,
        "cts": false,
        "x": 860,
        "y": 440,
        "wires": []
    },
    {
        "id": "96866108bbb66ddd",
        "type": "function",
        "z": "tab1",
        "name": "metricas",
        "func": "msg.payload = [{\n  \"Camadas\": msg.payload.layer,\n  \"Sucesso\": msg.payload.success_rate,\n  \"Perda\": msg.payload.packet_loss_rate,\n  \"RTT\": msg.payload.rtt_ms,\n  \"Nós na Rede\": msg.payload.children_count,\n  \"Trocas Pai\": msg.payload.parent_changes,\n  \"Ult. Troca\": msg.payload.last_parent_change_ms,\n  \"Retransmissões\": msg.payload.retransmission_count\n}];\nreturn msg;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 680,
        "wires": [
            [
                "table_metrics"
            ]
        ]
    },
    {
        "id": "b135aaf411c107cd",
        "type": "mqtt in",
        "z": "tab1",
        "name": "Sensor MQTT",
        "topic": "/topic/mesh/sensor",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 390,
        "y": 60,
        "wires": [
            [
                "21f94b3f363a211c"
            ]
        ]
    },
    {
        "id": "21f94b3f363a211c",
        "type": "function",
        "z": "tab1",
        "name": "temperatura",
        "func": "// Obtém o histórico salvo no fluxo ou inicia como objeto vazio\nlet historicosPorMac = flow.get(\"historicos_temp_por_mac\") || {};\n\n// Verifica se msg.payload.mac e msg.payload.temp são válidos\nif (msg.payload && msg.payload.mac && typeof msg.payload.temp === \"number\") {\n    let mac = msg.payload.mac;\n\n    // Inicializa o histórico para este MAC se ainda não existir\n    if (!historicosPorMac[mac]) {\n        historicosPorMac[mac] = [];\n    }\n\n    let dado = {\n        t: new Date().toLocaleTimeString(),\n        y: msg.payload.temp\n    };\n\n    historicosPorMac[mac].push(dado);\n\n    // Limita a 50 pontos para este MAC\n    if (historicosPorMac[mac].length > 50) {\n        historicosPorMac[mac].shift();\n    }\n\n    // Salva novamente no fluxo\n    flow.set(\"historicos_temp_por_mac\", historicosPorMac);\n\n    // Envia o objeto completo para o template\n    // O template vai iterar sobre isso para criar múltiplos gráficos\n    msg.payload = historicosPorMac;\n} else {\n    node.warn(\"Dado inválido: msg.payload.mac ou msg.payload.temp ausente/inválido\");\n    msg.payload = {}; // Envia um objeto vazio para evitar erros no template\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 60,
        "wires": [
            [
                "d25e1efb88d1af19"
            ]
        ]
    },
    {
        "id": "d25e1efb88d1af19",
        "type": "ui_template",
        "z": "tab1",
        "group": "grupo_sensores",
        "name": "",
        "order": 1,
        "width": 5,
        "height": 6,
        "format": "<style>\n    /* Estilos para o contêiner de todos os gráficos de temperatura */\n    .charts-container {\n        display: flex;\n        flex-direction: column;\n        /* Gráficos de MACs diferentes empilhados verticalmente */\n        gap: 20px;\n        /* Espaço entre os gráficos de MAC */\n        padding: 15px;\n        background-color: #222;\n        /* Fundo escuro */\n        border-radius: 8px;\n        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);\n        font-family: 'Inter', sans-serif;\n        /* Fonte Inter */\n        color: #eee;\n    }\n\n    /* Estilos para cada gráfico individual de temperatura por MAC */\n    .single-chart-wrapper {\n        background-color: #333;\n        padding: 10px;\n        border-radius: 8px;\n        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n        text-align: center;\n        width: 100%;\n        /* Ocupa a largura total do seu contêiner pai (o UI Template) */\n        max-width: 450px;\n        /* Limita a largura para melhor visualização */\n        margin: 0 auto;\n        /* Centraliza o wrapper */\n    }\n\n    .single-chart-wrapper h3 {\n        color: #ddd;\n        margin-bottom: 10px;\n        font-size: 1.1em;\n    }\n\n    canvas {\n        background-color: #444;\n        /* Fundo do canvas */\n        border-radius: 5px;\n        padding: 5px;\n        width: 100% !important;\n        /* Garante que o canvas seja responsivo */\n        height: auto !important;\n        /* Garante que o canvas seja responsivo */\n        max-height: 250px;\n        /* Altura máxima para os gráficos */\n        box-sizing: border-box;\n        /* Inclui padding e border no cálculo da largura */\n    }\n\n    /* Estilos para responsividade em telas menores */\n    @media (max-width: 750px) {\n        .charts-container {\n            padding: 10px;\n            gap: 15px;\n        }\n\n        .single-chart-wrapper {\n            max-width: 100%;\n            /* Permite que ocupe toda a largura em telas pequenas */\n        }\n    }\n</style>\n\n<div id=\"graficosContainerTemp\" class=\"charts-container\">\n    <!-- Os gráficos de temperatura serão injetados aqui via JavaScript -->\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n<script>\n    (function(scope) {\n        let charts = {}; // Objeto para armazenar as instâncias dos gráficos, indexadas pelo MAC\n\n        function criarOuAtualizarGrafico(mac, data) {\n            let container = document.getElementById(\"graficosContainerTemp\");\n            let canvasId = \"graficoTemp-\" + mac.replace(/:/g, \"-\"); // ID único para cada gráfico de temperatura por MAC\n\n            let canvas = document.getElementById(canvasId);\n            if (!canvas) {\n                // Se o canvas não existe, cria um novo wrapper e canvas\n                let div = document.createElement(\"div\");\n                div.className = \"single-chart-wrapper\";\n                div.innerHTML = `<h3>MAC: ${mac} - Temperatura (°C)</h3><canvas id=\"${canvasId}\"></canvas>`;\n                container.appendChild(div);\n                canvas = document.getElementById(canvasId);\n            }\n\n            const ctx = canvas.getContext(\"2d\");\n            const chartData = data.map(d => ({ x: d.t, y: d.y }));\n\n            if (charts[mac]) {\n                // Se o gráfico já existe, atualiza os dados\n                charts[mac].data.labels = data.map(d => d.t);\n                charts[mac].data.datasets[0].data = chartData;\n                charts[mac].update();\n            } else {\n                // Se o gráfico não existe, cria um novo\n                charts[mac] = new Chart(ctx, {\n                    type: 'line',\n                    data: {\n                        labels: data.map(d => d.t),\n                        datasets: [{\n                            label: `Temperatura (°C) - MAC: ${mac}`,\n                            data: chartData,\n                            fill: false,\n                            borderColor: 'red', // Cor para temperatura\n                            tension: 0.1\n                        }]\n                    },\n                    options: {\n                        responsive: true,\n                        maintainAspectRatio: false, // Permite que o canvas ajuste sua altura\n                        scales: {\n                            x: {\n                                title: { display: true, text: 'Hora', color: '#ccc' },\n                                type: 'category',\n                                ticks: { color: '#ccc' },\n                                grid: { color: 'rgba(255,255,255,0.1)' }\n                            },\n                            y: {\n                                beginAtZero: false,\n                                title: { display: true, text: 'Temperatura (°C)', color: '#ccc' },\n                                ticks: { color: '#ccc' },\n                                grid: { color: 'rgba(255,255,255,0.1)' }\n                            }\n                        },\n                        plugins: {\n                            legend: {\n                                labels: {\n                                    color: '#eee' // Cor da legenda\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        scope.$watch('msg.payload', function(payloadPorMac) {\n            if (typeof payloadPorMac !== 'object' || payloadPorMac === null) return;\n\n            // Remove gráficos de MACs que não estão mais no payload\n            for (let mac in charts) {\n                if (!payloadPorMac.hasOwnProperty(mac)) {\n                    charts[mac].destroy();\n                    delete charts[mac];\n                    let canvasToRemove = document.getElementById(\"graficoTemp-\" + mac.replace(/:/g, \"-\"));\n                    if (canvasToRemove && canvasToRemove.parentNode) {\n                        canvasToRemove.parentNode.remove(); // Remove o wrapper que contém o canvas e o h3\n                    }\n                }\n            }\n\n            // Cria ou atualiza gráficos para os MACs presentes no payload\n            for (let mac in payloadPorMac) {\n                if (payloadPorMac.hasOwnProperty(mac) && Array.isArray(payloadPorMac[mac])) {\n                    criarOuAtualizarGrafico(mac, payloadPorMac[mac]);\n                }\n            }\n        });\n    })(scope);\n</script>",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 820,
        "y": 60,
        "wires": [
            []
        ]
    },
    {
        "id": "97d50156fbfb4bd6",
        "type": "mqtt in",
        "z": "tab1",
        "name": "Sensor MQTT",
        "topic": "/topic/mesh/sensor",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 390,
        "y": 200,
        "wires": [
            [
                "d80ac32dba14a510"
            ]
        ]
    },
    {
        "id": "d80ac32dba14a510",
        "type": "function",
        "z": "tab1",
        "name": "umidade",
        "func": "// Obtém o histórico salvo no fluxo ou inicia como objeto vazio\nlet historicosPorMac = flow.get(\"historicos_hum_por_mac\") || {};\n\n// Verifica se msg.payload.mac e msg.payload.temp são válidos\nif (msg.payload && msg.payload.mac && typeof msg.payload.hum === \"number\") {\n    let mac = msg.payload.mac;\n\n    // Inicializa o histórico para este MAC se ainda não existir\n    if (!historicosPorMac[mac]) {\n        historicosPorMac[mac] = [];\n    }\n\n    let dado = {\n        t: new Date().toLocaleTimeString(),\n        y: msg.payload.hum\n    };\n\n    historicosPorMac[mac].push(dado);\n\n    // Limita a 50 pontos para este MAC\n    if (historicosPorMac[mac].length > 50) {\n        historicosPorMac[mac].shift();\n    }\n\n    // Salva novamente no fluxo\n    flow.set(\"historicos_hum_por_mac\", historicosPorMac);\n\n    // Envia o objeto completo para o template\n    // O template vai iterar sobre isso para criar múltiplos gráficos\n    msg.payload = historicosPorMac;\n} else {\n    node.warn(\"Dado inválido: msg.payload.mac ou msg.payload.hum ausente/inválido\");\n    msg.payload = {}; // Envia um objeto vazio para evitar erros no template\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 200,
        "wires": [
            [
                "c7a4a52ffb62729d"
            ]
        ]
    },
    {
        "id": "c7a4a52ffb62729d",
        "type": "ui_template",
        "z": "tab1",
        "group": "grupo_sensores",
        "name": "",
        "order": 2,
        "width": 5,
        "height": 6,
        "format": "<style>\n    /* Estilos para o contêiner de todos os gráficos de umidade */\n    .charts-container {\n        display: flex;\n        flex-direction: column;\n        /* Gráficos de MACs diferentes empilhados verticalmente */\n        gap: 20px;\n        /* Espaço entre os gráficos de MAC */\n        padding: 15px;\n        background-color: #222;\n        /* Fundo escuro */\n        border-radius: 8px;\n        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);\n        font-family: 'Inter', sans-serif;\n        /* Fonte Inter */\n        color: #eee;\n    }\n\n    /* Estilos para cada gráfico individual de umidade por MAC */\n    .single-chart-wrapper {\n        background-color: #333;\n        padding: 10px;\n        border-radius: 8px;\n        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n        text-align: center;\n        width: 100%;\n        /* Ocupa a largura total do seu contêiner pai (o UI Template) */\n        max-width: 450px;\n        /* Limita a largura para melhor visualização */\n        margin: 0 auto;\n        /* Centraliza o wrapper */\n    }\n\n    .single-chart-wrapper h3 {\n        color: #ddd;\n        margin-bottom: 10px;\n        font-size: 1.1em;\n    }\n\n    canvas {\n        background-color: #444;\n        /* Fundo do canvas */\n        border-radius: 5px;\n        padding: 5px;\n        width: 100% !important;\n        /* Garante que o canvas seja responsivo */\n        height: auto !important;\n        /* Garante que o canvas seja responsivo */\n        max-height: 250px;\n        /* Altura máxima para os gráficos */\n        box-sizing: border-box;\n        /* Inclui padding e border no cálculo da largura */\n    }\n\n    /* Estilos para responsividade em telas menores */\n    @media (max-width: 750px) {\n        .charts-container {\n            padding: 10px;\n            gap: 15px;\n        }\n\n        .single-chart-wrapper {\n            max-width: 100%;\n            /* Permite que ocupe toda a largura em telas pequenas */\n        }\n    }\n</style>\n\n<div id=\"graficosContainerHum\" class=\"charts-container\">\n    <!-- Os gráficos de umidade serão injetados aqui via JavaScript -->\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n<script>\n    (function(scope) {\n        let charts = {}; // Objeto para armazenar as instâncias dos gráficos, indexadas pelo MAC\n\n        function criarOuAtualizarGrafico(mac, data) {\n            let container = document.getElementById(\"graficosContainerHum\");\n            let canvasId = \"graficoHum-\" + mac.replace(/:/g, \"-\"); // ID único para cada gráfico de umidade por MAC\n\n            let canvas = document.getElementById(canvasId);\n            if (!canvas) {\n                // Se o canvas não existe, cria um novo wrapper e canvas\n                let div = document.createElement(\"div\");\n                div.className = \"single-chart-wrapper\";\n                div.innerHTML = `<h3>MAC: ${mac} - Umidade (%)</h3><canvas id=\"${canvasId}\"></canvas>`;\n                container.appendChild(div);\n                canvas = document.getElementById(canvasId);\n            }\n\n            const ctx = canvas.getContext(\"2d\");\n            const chartData = data.map(d => ({ x: d.t, y: d.y }));\n\n            if (charts[mac]) {\n                // Se o gráfico já existe, atualiza os dados\n                charts[mac].data.labels = data.map(d => d.t);\n                charts[mac].data.datasets[0].data = chartData;\n                charts[mac].update();\n            } else {\n                // Se o gráfico não existe, cria um novo\n                charts[mac] = new Chart(ctx, {\n                    type: 'line',\n                    data: {\n                        labels: data.map(d => d.t),\n                        datasets: [{\n                            label: `Umidade (%) - MAC: ${mac}`,\n                            data: chartData,\n                            fill: false,\n                            borderColor: 'blue', // Cor para umidade\n                            tension: 0.1\n                        }]\n                    },\n                    options: {\n                        responsive: true,\n                        maintainAspectRatio: false,\n                        scales: {\n                            x: {\n                                title: { display: true, text: 'Hora', color: '#ccc' },\n                                type: 'category',\n                                ticks: { color: '#ccc' },\n                                grid: { color: 'rgba(255,255,255,0.1)' }\n                            },\n                            y: {\n                                beginAtZero: false,\n                                title: { display: true, text: 'Umidade (%)', color: '#ccc' },\n                                ticks: { color: '#ccc' },\n                                grid: { color: 'rgba(255,255,255,0.1)' }\n                            }\n                        },\n                        plugins: {\n                            legend: {\n                                labels: {\n                                    color: '#eee'\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        scope.$watch('msg.payload', function(payloadPorMac) {\n            if (typeof payloadPorMac !== 'object' || payloadPorMac === null) return;\n\n            // Remove gráficos de MACs que não estão mais no payload\n            for (let mac in charts) {\n                if (!payloadPorMac.hasOwnProperty(mac)) {\n                    charts[mac].destroy();\n                    delete charts[mac];\n                    let canvasToRemove = document.getElementById(\"graficoHum-\" + mac.replace(/:/g, \"-\"));\n                    if (canvasToRemove && canvasToRemove.parentNode) {\n                        canvasToRemove.parentNode.remove();\n                    }\n                }\n            }\n\n            // Cria ou atualiza gráficos para os MACs presentes no payload\n            for (let mac in payloadPorMac) {\n                if (payloadPorMac.hasOwnProperty(mac) && Array.isArray(payloadPorMac[mac])) {\n                    criarOuAtualizarGrafico(mac, payloadPorMac[mac]);\n                }\n            }\n        });\n    })(scope);\n</script>",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 820,
        "y": 200,
        "wires": [
            []
        ]
    },
    {
        "id": "ca0161732f7ac35d",
        "type": "mqtt in",
        "z": "tab1",
        "name": "Sensor MQTT",
        "topic": "/topic/mesh/sensor",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 390,
        "y": 320,
        "wires": [
            [
                "73273bc023f09679"
            ]
        ]
    },
    {
        "id": "73273bc023f09679",
        "type": "function",
        "z": "tab1",
        "name": "latencia",
        "func": "// Obtém o histórico salvo no fluxo ou inicia como objeto vazio\nlet historicosPorMac = flow.get(\"historicos_lat_por_mac\") || {};\n\n// Verifica se msg.payload.mac e msg.payload.temp são válidos\nif (msg.payload && msg.payload.mac && typeof msg.payload.latency_ms === \"number\") {\n    let mac = msg.payload.mac;\n\n    // Inicializa o histórico para este MAC se ainda não existir\n    if (!historicosPorMac[mac]) {\n        historicosPorMac[mac] = [];\n    }\n\n    let dado = {\n        t: new Date().toLocaleTimeString(),\n        y: msg.payload.latency_ms\n    };\n\n    historicosPorMac[mac].push(dado);\n\n    // Limita a 50 pontos para este MAC\n    if (historicosPorMac[mac].length > 50) {\n        historicosPorMac[mac].shift();\n    }\n\n    // Salva novamente no fluxo\n    flow.set(\"historicos_lat_por_mac\", historicosPorMac);\n\n    // Envia o objeto completo para o template\n    // O template vai iterar sobre isso para criar múltiplos gráficos\n    msg.payload = historicosPorMac;\n} else {\n    node.warn(\"Dado inválido: msg.payload.mac ou msg.payload.latency_ms ausente/inválido\");\n    msg.payload = {}; // Envia um objeto vazio para evitar erros no template\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 320,
        "wires": [
            [
                "ec02d25f5e1a6405"
            ]
        ]
    },
    {
        "id": "ec02d25f5e1a6405",
        "type": "ui_template",
        "z": "tab1",
        "group": "grupo_sensores",
        "name": "",
        "order": 3,
        "width": 5,
        "height": 6,
        "format": "<style>\n    /* Estilos para o contêiner de todos os gráficos de latência */\n    .charts-container {\n        display: flex;\n        flex-direction: column;\n        /* Gráficos de MACs diferentes empilhados verticalmente */\n        gap: 20px;\n        /* Espaço entre os gráficos de MAC */\n        padding: 15px;\n        background-color: #222;\n        /* Fundo escuro */\n        border-radius: 8px;\n        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);\n        font-family: 'Inter', sans-serif;\n        /* Fonte Inter */\n        color: #eee;\n    }\n\n    /* Estilos para cada gráfico individual de latência por MAC */\n    .single-chart-wrapper {\n        background-color: #333;\n        padding: 10px;\n        border-radius: 8px;\n        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n        text-align: center;\n        width: 100%;\n        /* Ocupa a largura total do seu contêiner pai (o UI Template) */\n        max-width: 450px;\n        /* Limita a largura para melhor visualização */\n        margin: 0 auto;\n        /* Centraliza o wrapper */\n    }\n\n    .single-chart-wrapper h3 {\n        color: #ddd;\n        margin-bottom: 10px;\n        font-size: 1.1em;\n    }\n\n    canvas {\n        background-color: #444;\n        /* Fundo do canvas */\n        border-radius: 5px;\n        padding: 5px;\n        width: 100% !important;\n        /* Garante que o canvas seja responsivo */\n        height: auto !important;\n        /* Garante que o canvas seja responsivo */\n        max-height: 250px;\n        /* Altura máxima para os gráficos */\n        box-sizing: border-box;\n        /* Inclui padding e border no cálculo da largura */\n    }\n\n    /* Estilos para responsividade em telas menores */\n    @media (max-width: 750px) {\n        .charts-container {\n            padding: 10px;\n            gap: 15px;\n        }\n\n        .single-chart-wrapper {\n            max-width: 100%;\n            /* Permite que ocupe toda a largura em telas pequenas */\n        }\n    }\n</style>\n\n<div id=\"graficosContainerLat\" class=\"charts-container\">\n    <!-- Os gráficos de latência serão injetados aqui via JavaScript -->\n</div>\n\n<script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>\n<script>\n    (function(scope) {\n        let charts = {}; // Objeto para armazenar as instâncias dos gráficos, indexadas pelo MAC\n\n        function criarOuAtualizarGrafico(mac, data) {\n            let container = document.getElementById(\"graficosContainerLat\");\n            let canvasId = \"graficoLat-\" + mac.replace(/:/g, \"-\"); // ID único para cada gráfico de latência por MAC\n\n            let canvas = document.getElementById(canvasId);\n            if (!canvas) {\n                // Se o canvas não existe, cria um novo wrapper e canvas\n                let div = document.createElement(\"div\");\n                div.className = \"single-chart-wrapper\";\n                div.innerHTML = `<h3>MAC: ${mac} - Latência (ms)</h3><canvas id=\"${canvasId}\"></canvas>`;\n                container.appendChild(div);\n                canvas = document.getElementById(canvasId);\n            }\n\n            const ctx = canvas.getContext(\"2d\");\n            const chartData = data.map(d => ({ x: d.t, y: d.y }));\n\n            if (charts[mac]) {\n                // Se o gráfico já existe, atualiza os dados\n                charts[mac].data.labels = data.map(d => d.t);\n                charts[mac].data.datasets[0].data = chartData;\n                charts[mac].update();\n            } else {\n                // Se o gráfico não existe, cria um novo\n                charts[mac] = new Chart(ctx, {\n                    type: 'line',\n                    data: {\n                        labels: data.map(d => d.t),\n                        datasets: [{\n                            label: `Latência (ms) - MAC: ${mac}`,\n                            data: chartData,\n                            fill: false,\n                            borderColor: 'green', // Cor para latência\n                            tension: 0.1\n                        }]\n                    },\n                    options: {\n                        responsive: true,\n                        maintainAspectRatio: false,\n                        scales: {\n                            x: {\n                                title: { display: true, text: 'Hora', color: '#ccc' },\n                                type: 'category',\n                                ticks: { color: '#ccc' },\n                                grid: { color: 'rgba(255,255,255,0.1)' }\n                            },\n                            y: {\n                                beginAtZero: false,\n                                title: { display: true, text: 'Latência (ms)', color: '#ccc' },\n                                ticks: { color: '#ccc' },\n                                grid: { color: 'rgba(255,255,255,0.1)' }\n                            }\n                        },\n                        plugins: {\n                            legend: {\n                                labels: {\n                                    color: '#eee'\n                                }\n                            }\n                        }\n                    }\n                });\n            }\n        }\n\n        scope.$watch('msg.payload', function(payloadPorMac) {\n            if (typeof payloadPorMac !== 'object' || payloadPorMac === null) return;\n\n            // Remove gráficos de MACs que não estão mais no payload\n            for (let mac in charts) {\n                if (!payloadPorMac.hasOwnProperty(mac)) {\n                    charts[mac].destroy();\n                    delete charts[mac];\n                    let canvasToRemove = document.getElementById(\"graficoLat-\" + mac.replace(/:/g, \"-\"));\n                    if (canvasToRemove && canvasToRemove.parentNode) {\n                        canvasToRemove.parentNode.remove();\n                    }\n                }\n            }\n\n            // Cria ou atualiza gráficos para os MACs presentes no payload\n            for (let mac in payloadPorMac) {\n                if (payloadPorMac.hasOwnProperty(mac) && Array.isArray(payloadPorMac[mac])) {\n                    criarOuAtualizarGrafico(mac, payloadPorMac[mac]);\n                }\n            }\n        });\n    })(scope);\n</script>",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 820,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "6d03d4cb9e361f86",
        "type": "mqtt out",
        "z": "tab1",
        "name": "",
        "topic": "/topic/mesh/restart",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "mqtt_broker",
        "x": 1390,
        "y": 100,
        "wires": []
    },
    {
        "id": "858f35dda525e990",
        "type": "ui_button",
        "z": "tab1",
        "name": "",
        "group": "c43853a14aa4af82",
        "order": 1,
        "width": 0,
        "height": 0,
        "passthru": false,
        "label": "Reinicia Rede Mesh",
        "tooltip": "",
        "color": "",
        "bgcolor": "",
        "className": "",
        "icon": "",
        "payload": "restart_mesh",
        "payloadType": "str",
        "topic": "topic",
        "topicType": "msg",
        "x": 1120,
        "y": 100,
        "wires": [
            [
                "6d03d4cb9e361f86"
            ]
        ]
    },
    {
        "id": "5331b087743761df",
        "type": "mqtt in",
        "z": "tab1",
        "name": "",
        "topic": "/topic/mesh/rssi",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 1080,
        "y": 220,
        "wires": [
            [
                "cdba259c1214bcb5"
            ]
        ]
    },
    {
        "id": "cdba259c1214bcb5",
        "type": "function",
        "z": "tab1",
        "name": "signal",
        "func": "const payload = msg.payload;\n\n// Extrai e formata os valores\nconst macAddress = payload.mac || null;\nconst rssiRaw = parseInt(payload.rssi, 10);\nconst rssi = Number.isNaN(rssiRaw) ? null : rssiRaw;\n\n// Query SQL interpolada corretamente com crase\nmsg.topic = `INSERT INTO signal (mac, rssi) VALUES ('${macAddress}', ${rssi});`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 220,
        "wires": [
            [
                "bd855edacaabe2e9",
                "3aabf05b9eb9c9e8"
            ]
        ]
    },
    {
        "id": "a1d1e7cdcd59a6cd",
        "type": "sqlite",
        "z": "tab1",
        "mydb": "b931a41ca7c16188",
        "sqlquery": "msg.topic",
        "sql": "INSERT INTO signal(mac, rssi) VALUES (?, ?)\n",
        "name": "signal",
        "x": 1830,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "145efec868e512d1",
        "type": "mqtt in",
        "z": "tab1",
        "name": "",
        "topic": "/topic/mesh/metricas",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 1090,
        "y": 360,
        "wires": [
            [
                "71438fec4d2df473"
            ]
        ]
    },
    {
        "id": "71438fec4d2df473",
        "type": "function",
        "z": "tab1",
        "name": "metrics",
        "func": "const p = msg.payload;\n\nmsg.topic = `INSERT INTO metrics (\n    sucesso, perda, layer, nos, rtt, trocas_pai, ult_troca, retransmissoes\n) VALUES (\n    ${parseFloat(p.success_rate)},\n    ${parseFloat(p.packet_loss_rate)},\n    ${parseInt(p.layer, 10)},\n    ${parseInt(p.children_count, 10)},\n    ${parseInt(p.rtt_ms, 10)},\n    ${parseInt(p.parent_changes, 10)},\n    ${parseInt(p.last_parent_change_ms, 10)},\n    ${parseInt(p.retransmission_count, 10)}\n);`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1300,
        "y": 360,
        "wires": [
            [
                "d07c276b58e85c5e",
                "1b115ef813d73dc3"
            ]
        ]
    },
    {
        "id": "14dd0ea2434d40d1",
        "type": "sqlite",
        "z": "tab1",
        "mydb": "b931a41ca7c16188",
        "sqlquery": "msg.topic",
        "sql": "INSERT INTO metrics (\n    sucesso, perda, layer, nos, rtt, trocas_pai, ult_troca, retransmissoes\n) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
        "name": "metrics",
        "x": 1840,
        "y": 360,
        "wires": [
            []
        ]
    },
    {
        "id": "bd855edacaabe2e9",
        "type": "delay",
        "z": "tab1",
        "name": "",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1570,
        "y": 220,
        "wires": [
            [
                "a1d1e7cdcd59a6cd"
            ]
        ]
    },
    {
        "id": "d07c276b58e85c5e",
        "type": "delay",
        "z": "tab1",
        "name": "",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1610,
        "y": 360,
        "wires": [
            [
                "14dd0ea2434d40d1"
            ]
        ]
    },
    {
        "id": "d640521fc806dcb9",
        "type": "mqtt in",
        "z": "tab1",
        "name": "",
        "topic": "/topic/mesh/sensor",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "6ec4dcef.913b24",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 1090,
        "y": 500,
        "wires": [
            [
                "4cb3038b43f8a4af"
            ]
        ]
    },
    {
        "id": "4cb3038b43f8a4af",
        "type": "function",
        "z": "tab1",
        "name": "data_sensor",
        "func": "const payload = msg.payload;\n\n// Extrai e formata os valores\nconst macAddress = payload.mac;\nconst temperature = parseFloat(payload.temp).toFixed(2);\nconst humidity = parseFloat(payload.hum).toFixed(2);\nconst timestamp_ms = (parseInt(payload.latency_ms, 10));  // timestamp enviado pelo nó sensor (campo que você deve incluir)\n\nmsg.topic = `INSERT INTO mesh_sensor_data (mac, temperatura, umidade, latencia) VALUES ('${macAddress}', ${temperature}, ${humidity}, ${timestamp_ms});`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1370,
        "y": 520,
        "wires": [
            [
                "f08e9e5c2738be54",
                "f03ee1aae834aab3"
            ]
        ]
    },
    {
        "id": "f08e9e5c2738be54",
        "type": "delay",
        "z": "tab1",
        "name": "",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "milliseconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1610,
        "y": 520,
        "wires": [
            [
                "9131ed3b3b91ebdb"
            ]
        ]
    },
    {
        "id": "9131ed3b3b91ebdb",
        "type": "sqlite",
        "z": "tab1",
        "mydb": "b931a41ca7c16188",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "mesh_sensor_data",
        "x": 1810,
        "y": 520,
        "wires": [
            []
        ]
    },
    {
        "id": "3aabf05b9eb9c9e8",
        "type": "debug",
        "z": "tab1",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1420,
        "y": 280,
        "wires": []
    },
    {
        "id": "1b115ef813d73dc3",
        "type": "debug",
        "z": "tab1",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1500,
        "y": 440,
        "wires": []
    },
    {
        "id": "f03ee1aae834aab3",
        "type": "debug",
        "z": "tab1",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1540,
        "y": 600,
        "wires": []
    },
    {
        "id": "8c547d7b3fc3dd64",
        "type": "debug",
        "z": "tab1",
        "name": "debug 7",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 560,
        "y": 500,
        "wires": []
    }
]